<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tapendos - Multiplayer</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        @view-transition {
            navigation: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ Tapendos</h1>
        <p class="subtitle">Alternating Joy-Con vibration for <a href="https://en.wikipedia.org/wiki/Eye_movement_desensitization_and_reprocessing" target="_blank" rel="noopener noreferrer">EMDR</a></p>
        
        <div class="coming-soon-message">
            <h2>üöß Multiplayer Coming Soon</h2>
            <p>Multiplayer mode is currently under development. Please use single-player mode for now.</p>
            <a href="index.html" class="back-to-home-btn">‚Üê Back to Home</a>
        </div>
        
        <div id="status" class="status disconnected" style="display: none;">
            Disconnected
        </div>

        <!-- Pairing Flow UI (shown until connection established) -->
        <div id="pairingSection" class="pairing-section" style="display: none;">
            <!-- Player 1 Pairing Flow -->
            <div id="player1Pairing" class="pairing-flow" style="display: none;">
                <h2>Invite Player 2</h2>
                <div class="pairing-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <p class="step-title">Copy this link and send it to Player 2:</p>
                        <div class="session-link-box">
                            <input type="text" id="sessionLink" readonly class="session-link-input">
                            <button id="copyLinkBtn" class="copy-link-btn">Copy</button>
                        </div>
                    </div>
                </div>
                <div class="pairing-step" id="player1Step2" style="display: none;">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <p class="step-title">Paste Player 2's URL here:</p>
                        <div class="session-link-box">
                            <input type="text" id="answerUrlInput" class="session-link-input" 
                                   placeholder="Paste Player 2's URL here...">
                            <button id="connectAnswerBtn" class="copy-link-btn">Connect</button>
                        </div>
                        <p class="step-hint">Player 2 will send you their URL after they join</p>
                    </div>
                </div>
            </div>
            
            <!-- Player 2 Pairing Flow -->
            <div id="player2Pairing" class="pairing-flow" style="display: none;">
                <h2 id="player2InviteTitle">Player 1 invited you</h2>
                <div class="pairing-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <p class="step-title">Copy this URL and send it back to Player 1:</p>
                        <div class="session-link-box">
                            <input type="text" id="player2SessionLink" readonly class="session-link-input">
                            <button id="player2CopyLinkBtn" class="copy-link-btn">Copy</button>
                        </div>
                        <p class="step-hint">This will connect you to Player 1</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main UI (shown only after connection established) -->
        <div id="mainUI" style="display: none;">

            <!-- Player 2 Welcome Message -->
            <div id="player2Welcome" class="player2-welcome" style="display: none;">
                <h2>Welcome, Player 2!</h2>
                <p>You're connected to Player 1. Connect your Joy-Cons below to get started.</p>
                <p class="player2-instruction">Player 1 will control the vibration settings remotely.</p>
            </div>

            <div class="controls" id="player1Controls">
            <div class="control-group preset-select-group">
                <label for="presetSelect">
                    Presets
                </label>
                <select id="presetSelect"></select>
                <div id="presetCitation" class="preset-citation" style="display: none;"></div>
            </div>
            <div class="control-group">
                <label for="lengthSlider">
                    Pulse Length: <span id="lengthValue">500</span>ms
                </label>
                <input type="range" id="lengthSlider" min="10" max="2000" value="500" step="10">
            </div>

            <div class="control-group">
                <label for="intensitySlider">
                    Intensity: <span id="intensityValue">0.5</span>
                </label>
                <input type="range" id="intensitySlider" min="0" max="1" value="0.5" step="0.05">
            </div>

            <div class="control-group">
                <label for="pauseSlider">
                    Pause: <span id="pauseValue">800</span>ms
                </label>
                <input type="range" id="pauseSlider" min="0" max="3000" value="800" step="50">
            </div>

            <div class="control-group repeat-mode-group">
                <div class="repeat-mode-wrapper">
                    <label for="repeatModeSelect">
                        Repeat Mode:
                    </label>
                    <select id="repeatModeSelect">
                        <option value="unlimited">Unlimited</option>
                        <option value="count">Count</option>
                    </select>
                </div>
                <div id="repeatCountGroup" class="repeat-count-wrapper" style="display: none;">
                    <label for="repeatCountInput">
                        Repeat Count: <span id="repeatCountValue">1</span>
                    </label>
                    <input type="number" id="repeatCountInput" min="1" value="1" step="1">
                </div>
            </div>
            
            <div class="button-group">
                <button id="createSessionBtn" class="session-btn">Create Session</button>
            <div class="connect-buttons-row" id="player2ConnectButtons">
                <button id="connectLeftBtn" class="connect-btn">
                    <span class="status-indicator"></span>
                    <span class="button-label">Connect Left</span>
                </button>
                <button id="connectRightBtn" class="connect-btn">
                    <span class="status-indicator"></span>
                    <span class="button-label">Connect Right</span>
                </button>
            </div>
            <!-- Player 1 view of Player 2's controllers -->
            <div id="player2Controllers" class="player2-controllers" style="display: none;">
                <div class="player2-controller-status">
                    <div class="player2-controller-item">
                        <span class="status-indicator"></span>
                        <span class="controller-label">Player 2 Left Joy-Con</span>
                        <span class="controller-status-text">Not connected</span>
                    </div>
                    <div class="player2-controller-item">
                        <span class="status-indicator"></span>
                        <span class="controller-label">Player 2 Right Joy-Con</span>
                        <span class="controller-status-text">Not connected</span>
                    </div>
                </div>
            </div>
            <button id="vibrateBtn" class="vibrate-btn" disabled>Vibrate</button>
        </div>

        <div class="info">
            <strong>Note:</strong> Before connecting, make sure your Joy-Cons are paired with your computer via Bluetooth:
            <ul class="pairing-list">
                <li><strong>macOS:</strong> <a href="https://support.apple.com/guide/games/connect-a-game-controller-devf8cec167c/mac" target="_blank" rel="noopener noreferrer">Pairing instructions</a> ‚Äî Hold the sync button on your Joy-Con until lights flash, then select it in System Settings > Bluetooth</li>
                <li><strong>Windows:</strong> <a href="https://www.tomsguide.com/us/use-joy-cons-on-pc-mac,news-25419.html" target="_blank" rel="noopener noreferrer">Pairing instructions</a> ‚Äî Hold the sync button, then add via Settings > Devices > Bluetooth</li>
                <li><strong>iOS:</strong> Joy-Cons are not compatible with iOS devices. This app requires WebHID support (Chrome/Edge 89+ on desktop)</li>
            </ul>
        </div>
    </div>

    <script type="module">
        import { JoyCon } from './joycon.mjs';
        import { PeerConnectionManager, URLSignaling } from './webrtc-session.mjs';
        import { PRESETS, CUSTOM_PRESET_ID, LAST_PRESET_STORAGE_KEY } from './presets.mjs';

        // UI Management
        const connectLeftBtn = document.getElementById('connectLeftBtn');
        const connectRightBtn = document.getElementById('connectRightBtn');
        const vibrateBtn = document.getElementById('vibrateBtn');
        const statusDiv = document.getElementById('status');
        const player1Controls = document.getElementById('player1Controls');
        const player2ConnectButtons = document.getElementById('player2ConnectButtons');
        const player2Welcome = document.getElementById('player2Welcome');
        const player2Controllers = document.getElementById('player2Controllers');

        const lengthSlider = document.getElementById('lengthSlider');
        const lengthValue = document.getElementById('lengthValue');
        const intensitySlider = document.getElementById('intensitySlider');
        const intensityValue = document.getElementById('intensityValue');
        const pauseSlider = document.getElementById('pauseSlider');
        const pauseValue = document.getElementById('pauseValue');
        const repeatModeSelect = document.getElementById('repeatModeSelect');
        const repeatCountGroup = document.getElementById('repeatCountGroup');
        const repeatCountInput = document.getElementById('repeatCountInput');
        const repeatCountValue = document.getElementById('repeatCountValue');
        const presetSelect = document.getElementById('presetSelect');
        const presetCitation = document.getElementById('presetCitation');

        // Session UI elements
        const sessionSection = document.getElementById('sessionSection');
        const roleBadge = document.getElementById('roleBadge');
        const sessionStatus = document.getElementById('sessionStatus');
        const sessionLinkContainer = document.getElementById('sessionLinkContainer');
        const pairingSection = document.getElementById('pairingSection');
        const player1Pairing = document.getElementById('player1Pairing');
        const player2Pairing = document.getElementById('player2Pairing');
        const player2InviteTitle = document.getElementById('player2InviteTitle');
        const mainUI = document.getElementById('mainUI');
        const sessionLink = document.getElementById('sessionLink');
        const copyLinkBtn = document.getElementById('copyLinkBtn');
        const createSessionBtn = document.getElementById('createSessionBtn');
        const answerUrlInput = document.getElementById('answerUrlInput');
        const connectAnswerBtn = document.getElementById('connectAnswerBtn');
        const player1Step2 = document.getElementById('player1Step2');
        const player2SessionLink = document.getElementById('player2SessionLink');
        const player2CopyLinkBtn = document.getElementById('player2CopyLinkBtn');

        let joyCon = null;
        let currentRumbleAbortController = null;
        let currentRumblePromise = null;
        let activePresetId = CUSTOM_PRESET_ID;
        let isApplyingPreset = false;

        // WebRTC session state
        let peerManager = null;
        let sessionRole = null;
        let isRemoteSession = false;
        let answerWatcher = null;
        window.player2DeviceStatus = { left: false, right: false };

        intensityValue.textContent = formatAmplitudeDisplay(intensitySlider.value);

        // Update value displays when sliders change and apply live config
        lengthSlider.addEventListener('input', (e) => {
            lengthValue.textContent = e.target.value;
            if (!isApplyingPreset) {
                handleManualPresetOverride();
            }
            applyLiveConfig();
        });

        intensitySlider.addEventListener('input', (e) => {
            intensityValue.textContent = formatAmplitudeDisplay(e.target.value);
            if (!isApplyingPreset) {
                handleManualPresetOverride();
            }
            applyLiveConfig();
        });

        pauseSlider.addEventListener('input', (e) => {
            pauseValue.textContent = e.target.value;
            if (!isApplyingPreset) {
                handleManualPresetOverride();
            }
            applyLiveConfig();
        });

        repeatModeSelect.addEventListener('change', (e) => {
            const isCountMode = e.target.value === 'count';
            repeatCountGroup.style.display = isCountMode ? 'block' : 'none';
            applyLiveConfig();
        });

        repeatCountInput.addEventListener('input', (e) => {
            let value = parseInt(e.target.value, 10);
            if (isNaN(value) || value < 1) {
                value = 1;
            }
            repeatCountValue.textContent = value;
            e.target.value = value;
            applyLiveConfig();
        });

        function getCurrentConfig() {
            return {
                duration: parseInt(lengthSlider.value, 10),
                amplitude: parseFloat(intensitySlider.value),
                pauseDuration: parseInt(pauseSlider.value, 10),
                repeatMode: repeatModeSelect.value,
                repeatCount: parseInt(repeatCountInput.value, 10) || 1,
            };
        }

        async function applyLiveConfig() {
            if (isRemoteSession && sessionRole === 'therapist' && peerManager?.connectionState === 'connected') {
                // Send live update to Player 2
                const config = getCurrentConfig();
                peerManager.sendUpdateConfig(config);
            } else if (joyCon?.isVibrating && currentRumbleAbortController) {
                // Cancel current rumble and start new one with updated config
                currentRumbleAbortController.abort();
                currentRumbleAbortController = null;
                
                await new Promise(resolve => setTimeout(resolve, 10));
                
                if (joyCon?.isConnected) {
                    startRumble();
                }
            }
        }

        function updateButton(button, isConnected, label, isVibrating, isCurrentlyVibrating = false) {
            const indicator = button.querySelector('.status-indicator');
            const labelSpan = button.querySelector('.button-label');
            
            indicator.className = 'status-indicator';
            if (isConnected) {
                indicator.classList.add('connected');
            }
            if (isCurrentlyVibrating) {
                indicator.classList.add('vibrating');
            }
            
            if (isConnected) {
                labelSpan.textContent = label;
                button.classList.add('connected');
            } else {
                labelSpan.textContent = `Connect ${label}`;
                button.classList.remove('connected');
            }
            
            button.disabled = isVibrating;
        }

        function updateUI(state, error = null) {
            // Only update UI if we're connected (main UI is visible)
            if (!isRemoteSession || peerManager?.connectionState !== 'connected') {
                return; // Don't update UI during pairing
            }
            
            // Show/hide UI based on role (only when connected)
            if (sessionRole === 'therapist') {
                // Player 1 - hide connect buttons, show Player 2 status, show controls
                player2ConnectButtons.style.display = 'none';
                player2Controllers.style.display = 'block';
                player1Controls.style.display = 'block';
                player2Welcome.style.display = 'none';
            } else if (sessionRole === 'user') {
                // Player 2 - show connect buttons, hide controls, show welcome
                player2ConnectButtons.style.display = 'flex';
                player2Controllers.style.display = 'none';
                player1Controls.style.display = 'none';
                player2Welcome.style.display = 'block';
            }

            // Update status banner (only if connected)
            if (isRemoteSession && peerManager?.connectionState === 'connected') {
                if (error) {
                    statusDiv.textContent = error;
                    statusDiv.className = 'status error';
                } else if (sessionRole === 'user') {
                    // Player 2 status
                    statusDiv.textContent = 'Connected to Player 1 ‚Ä¢ Ready for vibration';
                    statusDiv.className = 'status connected';
                } else if (sessionRole === 'therapist') {
                    // Player 1 status
                    statusDiv.textContent = 'Connected to Player 2';
                    statusDiv.className = 'status connected';
                }
            } else if (!isRemoteSession) {
                // Local mode - show Joy-Con status
                if (error) {
                    statusDiv.textContent = error;
                    statusDiv.className = 'status error';
                } else if (!state.connected) {
                    statusDiv.textContent = 'No Joy-Con connected';
                    statusDiv.className = 'status disconnected';
                } else {
                    const devices = state.devices || { left: false, right: false };
                    const connectedCount = (devices.left ? 1 : 0) + (devices.right ? 1 : 0);
                    
                    if (connectedCount === 1) {
                        statusDiv.textContent = '1/2 Joy-Con Connected ‚Ä¢ connect both to enable vibration';
                    } else if (connectedCount === 2) {
                        statusDiv.textContent = 'Connected';
                    } else {
                        statusDiv.textContent = 'Connected';
                    }
                    statusDiv.className = 'status connected';
                }
            }
            
            // Only update buttons if connected
            if (isRemoteSession && peerManager?.connectionState === 'connected') {
                // Update buttons based on role
                if (sessionRole === 'user') {
                    // Player 2 - show connect buttons
                    const devices = state.devices || { left: false, right: false };
                    const vibratingSide = state.vibratingSide || null;
                    
                    updateButton(connectLeftBtn, devices.left, 'Left', state.vibrating, vibratingSide === 'left');
                    updateButton(connectRightBtn, devices.right, 'Right', state.vibrating, vibratingSide === 'right');
                    
                    // Player 2 - button disabled (Player 1 controls)
                    vibrateBtn.disabled = true;
                    vibrateBtn.textContent = 'Waiting for Player 1...';
                    vibrateBtn.className = 'vibrate-btn';
                } else if (sessionRole === 'therapist') {
                    // Player 1 - vibrate button enabled if Player 2 has controllers
                    const player2Devices = window.player2DeviceStatus || { left: false, right: false };
                    const bothConnected = player2Devices.left && player2Devices.right;
                    vibrateBtn.disabled = !bothConnected;
                    vibrateBtn.textContent = state.vibrating ? 'Stop' : 'Vibrate';
                    vibrateBtn.className = state.vibrating ? 'stop-btn' : 'vibrate-btn';
                }
            } else if (!isRemoteSession) {
                // Local mode - update all buttons
                const devices = state.devices || { left: false, right: false };
                const vibratingSide = state.vibratingSide || null;
                
                updateButton(connectLeftBtn, devices.left, 'Left', state.vibrating, vibratingSide === 'left');
                updateButton(connectRightBtn, devices.right, 'Right', state.vibrating, vibratingSide === 'right');
                
                if (state.vibrating) {
                    vibrateBtn.textContent = 'Stop';
                    vibrateBtn.className = 'stop-btn';
                } else {
                    vibrateBtn.textContent = 'Vibrate';
                    vibrateBtn.className = 'vibrate-btn';
                }
                const bothConnected = devices.left && devices.right;
                vibrateBtn.disabled = !bothConnected;
            }
        }

        function handleStateChange(state) {
            // Update remaining count display if in count mode and vibrating
            if (state.vibrating && state.remainingCount !== null && repeatModeSelect.value === 'count') {
                repeatCountValue.textContent = state.remainingCount;
            } else if (!state.vibrating && repeatModeSelect.value === 'count') {
                // Reset to original value when not vibrating
                repeatCountValue.textContent = repeatCountInput.value;
            }
            
            updateUI(state);
            
            // Send detailed Joy-Con connection status to Player 1 if Player 2
            if (isRemoteSession && sessionRole === 'user' && peerManager?.connectionState === 'connected') {
                peerManager.sendControllerStatus(state.devices || { left: false, right: false });
            }
        }

        function getCurrentState() {
            return joyCon ? {
                connected: joyCon.isConnected,
                vibrating: joyCon.isVibrating,
                deviceName: joyCon.deviceName,
                devices: joyCon.devices,
                vibratingSide: null,
                remainingCount: null
            } : {
                connected: false,
                vibrating: false,
                deviceName: 'Joy-Con',
                devices: { left: false, right: false },
                vibratingSide: null,
                remainingCount: null
            };
        }

        async function handleConnectLeft() {
            if (!joyCon) {
                joyCon = new JoyCon(handleStateChange);
            }

            try {
                const state = joyCon.devices;
                await (state.left ? joyCon.disconnectLeft() : joyCon.connectLeft());
            } catch (error) {
                updateUI(getCurrentState(), `Error: ${error.message}`);
            }
        }

        async function handleConnectRight() {
            if (!joyCon) {
                joyCon = new JoyCon(handleStateChange);
            }

            try {
                const state = joyCon.devices;
                await (state.right ? joyCon.disconnectRight() : joyCon.connectRight());
            } catch (error) {
                updateUI(getCurrentState(), `Error: ${error.message}`);
            }
        }

        async function startRumble() {
            if (!joyCon?.isConnected) {
                return;
            }

            const devices = joyCon.devices;
            if (!devices.left || !devices.right) {
                updateUI(getCurrentState(), 'Error: Both controllers must be connected to vibrate');
                return;
            }

            if (typeof joyCon.rumble !== 'function') {
                updateUI(getCurrentState(), 'Error: rumble method not available');
                return;
            }

            const config = getCurrentConfig();
            const abortController = new AbortController();
            currentRumbleAbortController = abortController;

            try {
                currentRumblePromise = joyCon.rumble({
                    lowFreq: 600,
                    highFreq: 600,
                    amplitude: config.amplitude,
                    duration: config.duration,
                    repeatMode: config.repeatMode,
                    repeatCount: config.repeatCount,
                    pauseDuration: config.pauseDuration,
                }, abortController.signal);

                await currentRumblePromise;
            } catch (error) {
                if (error.name !== 'AbortError') {
                    updateUI(getCurrentState(), `Vibration error: ${error.message}`);
                }
            } finally {
                if (currentRumbleAbortController === abortController) {
                    currentRumbleAbortController = null;
                    currentRumblePromise = null;
                }
            }
        }

        async function handleVibrate() {
            if (isRemoteSession && sessionRole === 'therapist' && peerManager?.connectionState === 'connected') {
                // Remote control mode - send command to Player 2
                if (joyCon?.isVibrating) {
                    peerManager.sendStop();
                } else {
                    const config = getCurrentConfig();
                    peerManager.sendVibrate(config);
                }
            } else {
                // Local control mode
                if (joyCon?.isVibrating) {
                    if (currentRumbleAbortController) {
                        currentRumbleAbortController.abort();
                        currentRumbleAbortController = null;
                    }
                    if (joyCon) {
                        joyCon.stop();
                    }
                } else {
                    await startRumble();
                }
            }
        }

        presetSelect.addEventListener('change', (event) => {
            const selectedId = event.target.value;
            if (selectedId === CUSTOM_PRESET_ID) {
                activePresetId = CUSTOM_PRESET_ID;
                setPresetHighlight(false);
                persistPresetSelection(CUSTOM_PRESET_ID);
            } else {
                applyPreset(selectedId);
            }
        });

        // Session Management Functions
        async function createSession() {
            try {
                createSessionBtn.disabled = true;
                createSessionBtn.textContent = 'Creating...';
                
                peerManager = new PeerConnectionManager('therapist', handleSessionStateChange, handleRemoteMessage);
                const offerSdp = await peerManager.createOffer();
                
                sessionRole = 'therapist';
                isRemoteSession = true;
                
                const shareUrl = URLSignaling.createTherapistURL(offerSdp);
                sessionLink.value = shareUrl;
                
                // Show pairing flow, hide main UI
                pairingSection.style.display = 'block';
                player1Pairing.style.display = 'block';
                player1Step2.style.display = 'none';
                mainUI.style.display = 'none';
                createSessionBtn.style.display = 'none';
                statusDiv.style.display = 'block';
                statusDiv.textContent = 'Copy the link above and send it to Player 2';
                statusDiv.className = 'status disconnected';
                
                // Watch for answer in URL (for page refresh scenarios)
                answerWatcher = URLSignaling.watchForAnswer(async (answerSdp) => {
                    try {
                        await peerManager.setAnswer(answerSdp);
                        // Connection will be handled by handleSessionStateChange
                    } catch (error) {
                        console.error('Error setting answer:', error);
                    }
                });
            } catch (error) {
                console.error('Error creating session:', error);
                createSessionBtn.disabled = false;
                createSessionBtn.textContent = 'Create Session';
            }
        }

        async function joinSession() {
            try {
                const offerSdp = URLSignaling.getOfferFromURL();
                if (!offerSdp) {
                    console.error('No offer found in URL');
                    if (statusDiv) {
                        statusDiv.style.display = 'block';
                        statusDiv.textContent = 'Invalid session link - no offer found';
                        statusDiv.className = 'status error';
                    }
                    return;
                }
                
                sessionRole = 'user';
                isRemoteSession = true;
                
                peerManager = new PeerConnectionManager('user', handleSessionStateChange, handleRemoteMessage);
                const answerSdp = await peerManager.createAnswer(offerSdp);
                
                // Update URL with answer
                const userUrl = URLSignaling.createUserURL(offerSdp, answerSdp);
                window.history.replaceState({}, '', userUrl);
                
                // Show Player 2 pairing flow
                pairingSection.style.display = 'block';
                player2Pairing.style.display = 'block';
                mainUI.style.display = 'none';
                createSessionBtn.style.display = 'none';
                statusDiv.style.display = 'block';
                
                // Show user's URL so they can share it with Player 1
                player2SessionLink.value = userUrl;
                
                // Update status
                statusDiv.textContent = 'Copy the URL below and send it back to Player 1';
                statusDiv.className = 'status disconnected';
                
                // Auto-copy URL to clipboard
                try {
                    await navigator.clipboard.writeText(userUrl);
                    // Show visual feedback on copy button
                    const originalText = player2CopyLinkBtn.textContent;
                    player2CopyLinkBtn.textContent = 'Copied!';
                    player2CopyLinkBtn.classList.add('copied');
                    setTimeout(() => {
                        player2CopyLinkBtn.textContent = originalText;
                        player2CopyLinkBtn.classList.remove('copied');
                    }, 3000);
                } catch (error) {
                    // Clipboard API not available, that's okay
                }
                
            } catch (error) {
                console.error('Error joining session:', error);
                if (statusDiv) {
                    statusDiv.style.display = 'block';
                    statusDiv.textContent = `Error joining session: ${error.message}`;
                    statusDiv.className = 'status error';
                }
            }
        }

        function handleSessionStateChange(state) {
            if (state === 'connected') {
                // Hide pairing flow, show main UI
                pairingSection.style.display = 'none';
                mainUI.style.display = 'block';
                
                if (sessionRole === 'therapist') {
                    // Player 1 - show controls and Player 2 status
                    player1Controls.style.display = 'block';
                    player2ConnectButtons.style.display = 'none';
                    player2Controllers.style.display = 'block';
                    player2Welcome.style.display = 'none';
                } else {
                    // Player 2 - show controller pairing only
                    player1Controls.style.display = 'none';
                    player2ConnectButtons.style.display = 'flex';
                    player2Controllers.style.display = 'none';
                    player2Welcome.style.display = 'block';
                    
                    // Send initial controller status
                    if (joyCon?.isConnected) {
                        const devices = joyCon.devices || { left: false, right: false };
                        peerManager.sendControllerStatus(devices);
                    } else {
                        peerManager.sendControllerStatus({ left: false, right: false });
                    }
                }
                
                // Update status
                if (statusDiv) {
                    if (sessionRole === 'therapist') {
                        statusDiv.textContent = 'Connected to Player 2';
                        statusDiv.className = 'status connected';
                    } else {
                        statusDiv.textContent = 'Connected to Player 1';
                        statusDiv.className = 'status connected';
                    }
                }
            } else if (state === 'disconnected' || state === 'failed') {
                // Show pairing flow again
                pairingSection.style.display = 'block';
                mainUI.style.display = 'none';
                
                if (sessionRole === 'therapist') {
                    player1Pairing.style.display = 'block';
                    player1Step2.style.display = 'block';
                } else {
                    player2Pairing.style.display = 'block';
                }
                
                if (statusDiv) {
                    if (sessionRole === 'therapist') {
                        statusDiv.textContent = 'Player 2 disconnected';
                        statusDiv.className = 'status error';
                    } else {
                        statusDiv.textContent = 'Connection lost';
                        statusDiv.className = 'status error';
                    }
                }
            } else if (state === 'connecting') {
                // Keep pairing flow visible while connecting
                if (statusDiv) {
                    if (sessionRole === 'user') {
                        statusDiv.textContent = 'Connecting to Player 1...';
                        statusDiv.className = 'status disconnected';
                    } else {
                        statusDiv.textContent = 'Connecting...';
                        statusDiv.className = 'status disconnected';
                    }
                }
            }
        }

        function handleRemoteMessage(message) {
            if (sessionRole === 'user') {
                // Player 2 receives commands from Player 1
                if (message.type === 'vibrate') {
                    if (joyCon?.isConnected) {
                        const config = message.config;
                        const abortController = new AbortController();
                        currentRumbleAbortController = abortController;
                        
                        currentRumblePromise = joyCon.rumble({
                            lowFreq: 600,
                            highFreq: 600,
                            amplitude: config.amplitude,
                            duration: config.duration,
                            repeatMode: config.repeatMode,
                            repeatCount: config.repeatCount,
                            pauseDuration: config.pauseDuration,
                        }, abortController.signal).catch(error => {
                            if (error.name !== 'AbortError') {
                                console.error('Vibration error:', error);
                                peerManager?.sendError(error.message);
                            }
                        });
                    }
                } else if (message.type === 'updateConfig') {
                    // Live update during vibration
                    if (joyCon?.isVibrating && currentRumbleAbortController) {
                        currentRumbleAbortController.abort();
                        currentRumbleAbortController = null;
                        
                        setTimeout(async () => {
                            if (joyCon?.isConnected) {
                                const config = message.config;
                                const abortController = new AbortController();
                                currentRumbleAbortController = abortController;
                                
                                currentRumblePromise = joyCon.rumble({
                                    lowFreq: 600,
                                    highFreq: 600,
                                    amplitude: config.amplitude,
                                    duration: config.duration,
                                    repeatMode: config.repeatMode,
                                    repeatCount: config.repeatCount,
                                    pauseDuration: config.pauseDuration,
                                }, abortController.signal).catch(error => {
                                    if (error.name !== 'AbortError') {
                                        console.error('Vibration error:', error);
                                    }
                                });
                            }
                        }, 10);
                    }
                } else if (message.type === 'stop') {
                    if (currentRumbleAbortController) {
                        currentRumbleAbortController.abort();
                        currentRumbleAbortController = null;
                    }
                    if (joyCon) {
                        joyCon.stop();
                    }
                }
            } else if (sessionRole === 'therapist') {
                // Player 1 receives status updates from Player 2
                if (message.type === 'controllerStatus') {
                    const devices = message.devices || { left: false, right: false };
                    const previousDevices = window.player2DeviceStatus || { left: false, right: false };
                    
                    // Update controller status display
                    updatePlayer2ControllerStatus(devices);
                    
                    // Show notifications for controller connections/disconnections
                    if (devices.left && !previousDevices.left) {
                        updateSessionStatus('Player 2 connected Left Joy-Con');
                        setTimeout(() => {
                            if (peerManager?.connectionState === 'connected') {
                                updateSessionStatus('Connected to Player 2');
                            }
                        }, 2000);
                    } else if (!devices.left && previousDevices.left) {
                        updateSessionStatus('Player 2 disconnected Left Joy-Con');
                    }
                    
                    if (devices.right && !previousDevices.right) {
                        updateSessionStatus('Player 2 connected Right Joy-Con');
                        setTimeout(() => {
                            if (peerManager?.connectionState === 'connected') {
                                updateSessionStatus('Connected to Player 2');
                            }
                        }, 2000);
                    } else if (!devices.right && previousDevices.right) {
                        updateSessionStatus('Player 2 disconnected Right Joy-Con');
                    }
                } else if (message.type === 'connected') {
                    updateSessionStatus(`Connected to Player 2 (Joy-Con: ${message.joyConConnected ? 'connected' : 'not connected'})`);
                } else if (message.type === 'error') {
                    updateSessionStatus(`Player 2 error: ${message.message}`);
                }
            }
        }

        function updatePlayer2ControllerStatus(devices) {
            window.player2DeviceStatus = devices;
            
            const leftItem = player2Controllers.querySelector('.player2-controller-item:first-child');
            const rightItem = player2Controllers.querySelector('.player2-controller-item:last-child');
            
            const leftIndicator = leftItem.querySelector('.status-indicator');
            const leftStatusText = leftItem.querySelector('.controller-status-text');
            if (devices.left) {
                leftIndicator.className = 'status-indicator connected';
                leftStatusText.textContent = 'Connected';
            } else {
                leftIndicator.className = 'status-indicator';
                leftStatusText.textContent = 'Not connected';
            }
            
            const rightIndicator = rightItem.querySelector('.status-indicator');
            const rightStatusText = rightItem.querySelector('.controller-status-text');
            if (devices.right) {
                rightIndicator.className = 'status-indicator connected';
                rightStatusText.textContent = 'Connected';
            } else {
                rightIndicator.className = 'status-indicator';
                rightStatusText.textContent = 'Not connected';
            }
        }

        function updateSessionStatus(text) {
            sessionStatus.textContent = text;
        }

        function copySessionLink(inputElement, buttonElement) {
            inputElement.select();
            inputElement.setSelectionRange(0, 99999);
            
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(inputElement.value).then(() => {
                    showCopyFeedback(buttonElement);
                }).catch(() => {
                    // Fallback to execCommand
                    document.execCommand('copy');
                    showCopyFeedback(buttonElement);
                });
            } else {
                // Fallback for older browsers
                document.execCommand('copy');
                showCopyFeedback(buttonElement);
            }
        }
        
        function showCopyFeedback(buttonElement) {
            const originalText = buttonElement.textContent;
            buttonElement.textContent = 'Copied!';
            buttonElement.classList.add('copied');
            setTimeout(() => {
                buttonElement.textContent = originalText;
                buttonElement.classList.remove('copied');
            }, 2000);
        }
        
        async function handlePastedAnswerUrl(url) {
            if (!url || !url.trim()) {
                if (statusDiv) {
                    statusDiv.textContent = 'Please paste Player 2\'s URL';
                    statusDiv.className = 'status error';
                }
                answerUrlInput.focus();
                return;
            }
            
            try {
                const answerSdp = URLSignaling.getAnswerFromURL(url);
                if (!answerSdp) {
                    if (statusDiv) {
                        statusDiv.textContent = 'Invalid URL. Make sure you pasted Player 2\'s complete URL.';
                        statusDiv.className = 'status error';
                    }
                    answerUrlInput.select();
                    return;
                }
                
                if (!peerManager) {
                    if (statusDiv) {
                        statusDiv.textContent = 'Session not initialized. Please refresh and try again.';
                        statusDiv.className = 'status error';
                    }
                    return;
                }
                
                if (statusDiv) {
                    statusDiv.textContent = 'Connecting to Player 2...';
                    statusDiv.className = 'status disconnected';
                }
                connectAnswerBtn.disabled = true;
                connectAnswerBtn.textContent = 'Connecting...';
                answerUrlInput.disabled = true;
                
                await peerManager.setAnswer(answerSdp);
                // Connection will complete via handleSessionStateChange
                
            } catch (error) {
                console.error('Error connecting with answer:', error);
                if (statusDiv) {
                    statusDiv.textContent = `Connection failed: ${error.message}`;
                    statusDiv.className = 'status error';
                }
                connectAnswerBtn.disabled = false;
                connectAnswerBtn.textContent = 'Connect';
                answerUrlInput.disabled = false;
                answerUrlInput.select();
            }
        }

        // Initialize session based on URL query params
        function initializeSession() {
            const role = URLSignaling.getRoleFromURL();
            
            if (role === 'therapist' || role === 'patient') {
                // Player 1 (therapist) - if offer exists, restore session UI
                const offer = URLSignaling.getOfferFromURL();
                const answer = URLSignaling.getAnswerFromURL();
                
                if (offer && !answer) {
                    // Session created but user hasn't joined yet - restore UI and watch for answer
                    createSessionBtn.style.display = 'none';
                    sessionSection.style.display = 'block';
                    roleBadge.textContent = 'Player 1 (Controls)';
                    roleBadge.className = 'role-badge multiplayer';
                    sessionLink.value = window.location.href;
                    sessionLinkContainer.style.display = 'block';
                    isRemoteSession = true;
                    sessionRole = 'therapist';
                    updateSessionStatus('‚è≥ Waiting for Player 2 to join and share their URL...');
                    answerInputContainer.style.display = 'block';
                    answerInputHint.style.display = 'block';
                    
                    // Watch for answer to be added to URL (for page refresh scenarios)
                    answerWatcher = URLSignaling.watchForAnswer(async (answerSdp) => {
                        if (!peerManager) {
                            peerManager = new PeerConnectionManager('therapist', handleSessionStateChange, handleRemoteMessage);
                            await peerManager.createOffer();
                        }
                        try {
                            await peerManager.setAnswer(answerSdp);
                            updateSessionStatus('‚úÖ Connected to Player 2');
                            answerInputContainer.style.display = 'none';
                        } catch (error) {
                            updateSessionStatus(`‚ùå Error: ${error.message}`);
                        }
                    });
                } else if (offer && answer) {
                    // Both offer and answer exist - session was active but page refreshed
                    URLSignaling.clearURL();
                    createSessionBtn.style.display = 'block';
                } else {
                    // No offer yet - show create session button
                    createSessionBtn.style.display = 'block';
                }
            } else if (role === 'user') {
                // Player 2 (user) - auto-join session
                setTimeout(() => {
                    joinSession();
                }, 100);
            } else {
                // No role - show create session button (Player 1)
                createSessionBtn.style.display = 'block';
            }
        }

        copyLinkBtn.addEventListener('click', () => {
            copySessionLink(sessionLink, copyLinkBtn);
        });
        
        player2CopyLinkBtn.addEventListener('click', () => {
            copySessionLink(player2SessionLink, player2CopyLinkBtn);
        });
        
        createSessionBtn.addEventListener('click', createSession);
        connectLeftBtn.addEventListener('click', handleConnectLeft);
        connectRightBtn.addEventListener('click', handleConnectRight);
        vibrateBtn.addEventListener('click', handleVibrate);
        connectAnswerBtn.addEventListener('click', async () => {
            const url = answerUrlInput.value.trim();
            await handlePastedAnswerUrl(url);
        });
        
        // Auto-detect paste in answer input
        answerUrlInput.addEventListener('paste', async (e) => {
            // Small delay to let paste complete
            setTimeout(async () => {
                const pastedUrl = answerUrlInput.value.trim();
                if (pastedUrl) {
                    await handlePastedAnswerUrl(pastedUrl);
                }
            }, 10);
        });
        
        // Also handle Enter key in answer input
        answerUrlInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const url = answerUrlInput.value.trim();
                await handlePastedAnswerUrl(url);
            }
        });

        initializePresets();
        initializeSession();

        // Initialize UI
        updateUI({ connected: false, vibrating: false, deviceName: 'Joy-Con', devices: { left: false, right: false }, vibratingSide: null });

        if (!navigator.hid) {
            statusDiv.textContent = 'WebHID not supported. Use Chrome/Edge 89+';
            connectLeftBtn.disabled = true;
            connectRightBtn.disabled = true;
        } else {
            navigator.hid.addEventListener('disconnect', (event) => {
                if (joyCon) {
                    joyCon.handleDisconnect(event.device);
                }
            });
        }

        function formatAmplitudeDisplay(value) {
            const parsed = Number(value);
            if (!Number.isFinite(parsed)) {
                return value;
            }
            return (Math.round(parsed * 100) / 100).toString();
        }

        function persistPresetSelection(id) {
            try {
                localStorage.setItem(LAST_PRESET_STORAGE_KEY, id);
            } catch (error) {
                // Ignore storage limitations
            }
        }

        function loadStoredPreset() {
            try {
                return localStorage.getItem(LAST_PRESET_STORAGE_KEY);
            } catch (error) {
                return null;
            }
        }

        function populatePresetOptions() {
            const fragment = document.createDocumentFragment();
            const customOption = document.createElement('option');
            customOption.value = CUSTOM_PRESET_ID;
            customOption.textContent = 'Custom';
            fragment.appendChild(customOption);

            PRESETS.forEach((preset) => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = `${preset.name} ‚Äî ${preset.tagline}`;
                fragment.appendChild(option);
            });

            presetSelect.innerHTML = '';
            presetSelect.appendChild(fragment);
        }

        function setPresetHighlight(isPreset) {
            presetSelect.classList.toggle('preset-active', isPreset);
        }

        function applyPreset(presetId, { persist = true } = {}) {
            const preset = PRESETS.find((item) => item.id === presetId);
            if (!preset) {
                activePresetId = CUSTOM_PRESET_ID;
                presetSelect.value = CUSTOM_PRESET_ID;
                setPresetHighlight(false);
                if (persist) {
                    persistPresetSelection(CUSTOM_PRESET_ID);
                }
                return;
            }

            isApplyingPreset = true;
            activePresetId = presetId;
            presetSelect.value = presetId;

            setPresetHighlight(true);

            lengthSlider.value = preset.values.duration;
            lengthValue.textContent = preset.values.duration;
            intensitySlider.value = preset.values.amplitude;
            intensityValue.textContent = formatAmplitudeDisplay(preset.values.amplitude);
            pauseSlider.value = preset.values.pauseDuration;
            pauseValue.textContent = preset.values.pauseDuration;
            
            // Apply repeat mode and count if specified
            if (preset.values.repeatMode !== undefined) {
                repeatModeSelect.value = preset.values.repeatMode;
                const isCountMode = preset.values.repeatMode === 'count';
                repeatCountGroup.style.display = isCountMode ? 'block' : 'none';
            }
            if (preset.values.repeatCount !== undefined) {
                repeatCountInput.value = preset.values.repeatCount;
                repeatCountValue.textContent = preset.values.repeatCount;
            }
            
            // Hide citation display
            presetCitation.style.display = 'none';
            
            lengthSlider.dispatchEvent(new Event('input'));
            intensitySlider.dispatchEvent(new Event('input'));
            pauseSlider.dispatchEvent(new Event('input'));
            repeatModeSelect.dispatchEvent(new Event('change'));

            isApplyingPreset = false;

            if (persist) {
                persistPresetSelection(presetId);
            }

            applyLiveConfig();
        }

        function handleManualPresetOverride() {
            if (activePresetId === CUSTOM_PRESET_ID) {
                return;
            }

            activePresetId = CUSTOM_PRESET_ID;
            presetSelect.value = CUSTOM_PRESET_ID;
            setPresetHighlight(false);
            persistPresetSelection(CUSTOM_PRESET_ID);
        }

        function initializePresets() {
            populatePresetOptions();
            const storedPresetId = loadStoredPreset();
            if (storedPresetId && PRESETS.some((preset) => preset.id === storedPresetId)) {
                applyPreset(storedPresetId, { persist: false });
            } else {
                presetSelect.value = CUSTOM_PRESET_ID;
                setPresetHighlight(false);
            }
        }
    </script>
</body>
</html>

